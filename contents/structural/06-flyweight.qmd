---
title: "Flyweight"
---

The **Flyweight** pattern shares common state among multiple objects to minimize memory usage. It separates **intrinsic state** (shared, immutable) from **extrinsic state** (unique per context) — essential when you need to create a huge number of similar objects.

## Problem

Imagine you're building a text editor that renders thousands of characters. Each character has formatting (font, size, color) and a position. The naive approach stores all data in each character object.

With 10,000 characters using the same font:

- 10,000 copies of font name string
- 10,000 copies of size value
- 10,000 copies of color string
- Massive memory waste!

### Example

```{mermaid}
flowchart LR
    subgraph "10,000 Character Objects"
        C1["char: 'H'<br/>font: 'Arial'<br/>size: 12<br/>color: 'black'<br/>row: 0, col: 0"]
        C2["char: 'e'<br/>font: 'Arial'<br/>size: 12<br/>color: 'black'<br/>row: 0, col: 1"]
        C3["char: 'l'<br/>font: 'Arial'<br/>size: 12<br/>color: 'black'<br/>row: 0, col: 2"]
        C4["...9,997 more..."]
    end

    style C1 fill:#fcc,stroke:#c33
    style C2 fill:#fcc,stroke:#c33
    style C3 fill:#fcc,stroke:#c33
```

**Problems with this approach:**

- Each character duplicates font data (even when identical)
- Memory grows linearly with character count
- Doesn't scale for large documents

::: {.panel-tabset}
#### `Python`

```python
class Character:
    def __init__(self, char: str, font: str, size: int, color: str, row: int, col: int):
        self.char = char
        self.font = font      # Duplicated across all characters!
        self.size = size      # Duplicated!
        self.color = color    # Duplicated!
        self.row = row
        self.col = col

    def render(self) -> None:
        print(f"'{self.char}' at ({self.row},{self.col}) "
              f"[{self.font}, {self.size}pt, {self.color}]")

# Creating 10,000 characters = 10,000 copies of "Arial", 12, "black"
characters: list[Character] = []
text = "Hello World! " * 770  # ~10,000 characters

for i, char in enumerate(text):
    characters.append(Character(char, "Arial", 12, "black", i // 80, i % 80))
```

#### `C#`

```csharp
public class Character
{
    public char Char { get; }
    public string Font { get; }    // Duplicated across all characters!
    public int Size { get; }       // Duplicated!
    public string Color { get; }   // Duplicated!
    public int Row { get; }
    public int Col { get; }

    public Character(char c, string font, int size, string color, int row, int col)
    {
        Char = c;
        Font = font;
        Size = size;
        Color = color;
        Row = row;
        Col = col;
    }

    public void Render()
    {
        Console.WriteLine($"'{Char}' at ({Row},{Col}) [{Font}, {Size}pt, {Color}]");
    }
}

// Creating 10,000 characters = 10,000 copies of font data
var characters = new List<Character>();
var text = string.Concat(Enumerable.Repeat("Hello World! ", 770));

for (int i = 0; i < text.Length; i++)
{
    characters.Add(new Character(text[i], "Arial", 12, "black", i / 80, i % 80));
}
```

#### `TypeScript`

```typescript
class Character {
  constructor(
    public char: string,
    public font: string,    // Duplicated across all characters!
    public size: number,    // Duplicated!
    public color: string,   // Duplicated!
    public row: number,
    public col: number
  ) {}

  render(): void {
    console.log(
      `'${this.char}' at (${this.row},${this.col}) ` +
      `[${this.font}, ${this.size}pt, ${this.color}]`
    );
  }
}

// Creating 10,000 characters = 10,000 copies of font data
const characters: Character[] = [];
const text = "Hello World! ".repeat(770);

for (let i = 0; i < text.length; i++) {
  characters.push(
    new Character(text[i], "Arial", 12, "black", Math.floor(i / 80), i % 80)
  );
}
```

#### `Dart`

```dart
class Character {
  final String char;
  final String font;    // Duplicated across all characters!
  final int size;       // Duplicated!
  final String color;   // Duplicated!
  final int row;
  final int col;

  Character(this.char, this.font, this.size, this.color, this.row, this.col);

  void render() {
    print("'$char' at ($row,$col) [$font, ${size}pt, $color]");
  }
}

void main() {
  // Creating 10,000 characters = 10,000 copies of font data
  final characters = <Character>[];
  final text = "Hello World! " * 770;

  for (var i = 0; i < text.length; i++) {
    characters.add(Character(text[i], "Arial", 12, "black", i ~/ 80, i % 80));
  }
}
```

:::

#### Usage

::: {.panel-tabset}
#### `Python`

```python
# 10,000 character objects, each with duplicated font data
print(f"Created {len(characters)} characters")
characters[0].render()  # 'H' at (0,0) [Arial, 12pt, black]
characters[1].render()  # 'e' at (0,1) [Arial, 12pt, black]

# Memory: 10,000 × (char + font + size + color + position)
```

#### `C#`

```csharp
// 10,000 character objects, each with duplicated font data
Console.WriteLine($"Created {characters.Count} characters");
characters[0].Render();  // 'H' at (0,0) [Arial, 12pt, black]
characters[1].Render();  // 'e' at (0,1) [Arial, 12pt, black]

// Memory: 10,000 × (char + font + size + color + position)
```

#### `TypeScript`

```typescript
// 10,000 character objects, each with duplicated font data
console.log(`Created ${characters.length} characters`);
characters[0].render();  // 'H' at (0,0) [Arial, 12pt, black]
characters[1].render();  // 'e' at (0,1) [Arial, 12pt, black]

// Memory: 10,000 × (char + font + size + color + position)
```

#### `Dart`

```dart
void main() {
  // 10,000 character objects, each with duplicated font data
  print("Created ${characters.length} characters");
  characters[0].render();  // 'H' at (0,0) [Arial, 12pt, black]
  characters[1].render();  // 'e' at (0,1) [Arial, 12pt, black]

  // Memory: 10,000 × (char + font + size + color + position)
}
```

:::


## Solution

The Flyweight pattern solves this by:

1. Extracting **intrinsic state** (font, size, color) into a shared `CharacterStyle` flyweight
2. Using a **factory** to cache and reuse flyweight instances
3. Storing only a **reference** to the flyweight + extrinsic state (position) in each character

With 10,000 characters but only 3 unique styles → only 3 style objects in memory!

### UML Diagram

```{mermaid}
classDiagram
    class CharacterStyle {
        <<flyweight>>
        -font: String
        -size: int
        -color: String
        +render(char, row, col)
    }

    class StyleFactory {
        -cache: Map~String, CharacterStyle~
        +getStyle(font, size, color) CharacterStyle
    }

    class Character {
        -char: String
        -style: CharacterStyle
        -row: int
        -col: int
        +render()
    }

    StyleFactory --> CharacterStyle : creates/caches
    Character --> CharacterStyle : shares
```

### Refactored Code

::: {.panel-tabset}
#### `Python`

```python
# Flyweight - stores intrinsic state only
class CharacterStyle:
    def __init__(self, font: str, size: int, color: str):
        self.font = font
        self.size = size
        self.color = color

    def render(self, char: str, row: int, col: int) -> None:
        print(f"'{char}' at ({row},{col}) [{self.font}, {self.size}pt, {self.color}]")

# Flyweight Factory - caches and reuses instances
class StyleFactory:
    _cache: dict[str, CharacterStyle] = {}

    @classmethod
    def get_style(cls, font: str, size: int, color: str) -> CharacterStyle:
        key = f"{font}_{size}_{color}"
        if key not in cls._cache:
            cls._cache[key] = CharacterStyle(font, size, color)
            print(f"StyleFactory: Created new style '{key}'")
        return cls._cache[key]

    @classmethod
    def get_style_count(cls) -> int:
        return len(cls._cache)

# Context - stores extrinsic state + reference to flyweight
class Character:
    def __init__(self, char: str, style: CharacterStyle, row: int, col: int):
        self.char = char
        self.style = style  # Shared reference!
        self.row = row
        self.col = col

    def render(self) -> None:
        self.style.render(self.char, self.row, self.col)
```

#### `C#`

```csharp
// Flyweight - stores intrinsic state only
public class CharacterStyle
{
    public string Font { get; }
    public int Size { get; }
    public string Color { get; }

    public CharacterStyle(string font, int size, string color)
    {
        Font = font;
        Size = size;
        Color = color;
    }

    public void Render(char c, int row, int col)
    {
        Console.WriteLine($"'{c}' at ({row},{col}) [{Font}, {Size}pt, {Color}]");
    }
}

// Flyweight Factory - caches and reuses instances
public class StyleFactory
{
    private static readonly Dictionary<string, CharacterStyle> Cache = new();

    public static CharacterStyle GetStyle(string font, int size, string color)
    {
        var key = $"{font}_{size}_{color}";
        if (!Cache.TryGetValue(key, out var style))
        {
            style = new CharacterStyle(font, size, color);
            Cache[key] = style;
            Console.WriteLine($"StyleFactory: Created new style '{key}'");
        }
        return style;
    }

    public static int StyleCount => Cache.Count;
}

// Context - stores extrinsic state + reference to flyweight
public class Character
{
    public char Char { get; }
    public CharacterStyle Style { get; }  // Shared reference!
    public int Row { get; }
    public int Col { get; }

    public Character(char c, CharacterStyle style, int row, int col)
    {
        Char = c;
        Style = style;
        Row = row;
        Col = col;
    }

    public void Render() => Style.Render(Char, Row, Col);
}
```

#### `TypeScript`

```typescript
// Flyweight - stores intrinsic state only
class CharacterStyle {
  constructor(
    public readonly font: string,
    public readonly size: number,
    public readonly color: string
  ) {}

  render(char: string, row: number, col: number): void {
    console.log(
      `'${char}' at (${row},${col}) [${this.font}, ${this.size}pt, ${this.color}]`
    );
  }
}

// Flyweight Factory - caches and reuses instances
class StyleFactory {
  private static cache = new Map<string, CharacterStyle>();

  static getStyle(font: string, size: number, color: string): CharacterStyle {
    const key = `${font}_${size}_${color}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new CharacterStyle(font, size, color));
      console.log(`StyleFactory: Created new style '${key}'`);
    }
    return this.cache.get(key)!;
  }

  static get styleCount(): number {
    return this.cache.size;
  }
}

// Context - stores extrinsic state + reference to flyweight
class Character {
  constructor(
    public readonly char: string,
    public readonly style: CharacterStyle,  // Shared reference!
    public readonly row: number,
    public readonly col: number
  ) {}

  render(): void {
    this.style.render(this.char, this.row, this.col);
  }
}
```

#### `Dart`

```dart
// Flyweight - stores intrinsic state only
class CharacterStyle {
  final String font;
  final int size;
  final String color;

  CharacterStyle(this.font, this.size, this.color);

  void render(String char, int row, int col) {
    print("'$char' at ($row,$col) [$font, ${size}pt, $color]");
  }
}

// Flyweight Factory - caches and reuses instances
class StyleFactory {
  static final Map<String, CharacterStyle> _cache = {};

  static CharacterStyle getStyle(String font, int size, String color) {
    final key = "${font}_${size}_$color";
    if (!_cache.containsKey(key)) {
      _cache[key] = CharacterStyle(font, size, color);
      print("StyleFactory: Created new style '$key'");
    }
    return _cache[key]!;
  }

  static int get styleCount => _cache.length;
}

// Context - stores extrinsic state + reference to flyweight
class Character {
  final String char;
  final CharacterStyle style;  // Shared reference!
  final int row;
  final int col;

  Character(this.char, this.style, this.row, this.col);

  void render() => style.render(char, row, col);
}
```

:::

#### Usage

::: {.panel-tabset}
#### `Python`

```python
# Create 10,000 characters with shared styles
characters: list[Character] = []
text = "Hello World! " * 770

for i, char in enumerate(text):
    # Factory returns cached style — same object for same parameters
    style = StyleFactory.get_style("Arial", 12, "black")
    characters.append(Character(char, style, i // 80, i % 80))

print(f"\nCreated {len(characters)} characters")
print(f"Using only {StyleFactory.get_style_count()} style object(s)!")

characters[0].render()  # 'H' at (0,0) [Arial, 12pt, black]
characters[1].render()  # 'e' at (0,1) [Arial, 12pt, black]

# Verify same style object is shared
print(f"\nSame style? {characters[0].style is characters[1].style}")  # True

# Output:
# StyleFactory: Created new style 'Arial_12_black'
# Created 10010 characters
# Using only 1 style object(s)!
```

#### `C#`

```csharp
// Create 10,000 characters with shared styles
var characters = new List<Character>();
var text = string.Concat(Enumerable.Repeat("Hello World! ", 770));

for (int i = 0; i < text.Length; i++)
{
    // Factory returns cached style — same object for same parameters
    var style = StyleFactory.GetStyle("Arial", 12, "black");
    characters.Add(new Character(text[i], style, i / 80, i % 80));
}

Console.WriteLine($"\nCreated {characters.Count} characters");
Console.WriteLine($"Using only {StyleFactory.StyleCount} style object(s)!");

characters[0].Render();  // 'H' at (0,0) [Arial, 12pt, black]
characters[1].Render();  // 'e' at (0,1) [Arial, 12pt, black]

// Verify same style object is shared
Console.WriteLine($"\nSame style? {ReferenceEquals(characters[0].Style, characters[1].Style)}");

// Output:
// StyleFactory: Created new style 'Arial_12_black'
// Created 10010 characters
// Using only 1 style object(s)!
```

#### `TypeScript`

```typescript
// Create 10,000 characters with shared styles
const characters: Character[] = [];
const text = "Hello World! ".repeat(770);

for (let i = 0; i < text.length; i++) {
  // Factory returns cached style — same object for same parameters
  const style = StyleFactory.getStyle("Arial", 12, "black");
  characters.push(new Character(text[i], style, Math.floor(i / 80), i % 80));
}

console.log(`\nCreated ${characters.length} characters`);
console.log(`Using only ${StyleFactory.styleCount} style object(s)!`);

characters[0].render();  // 'H' at (0,0) [Arial, 12pt, black]
characters[1].render();  // 'e' at (0,1) [Arial, 12pt, black]

// Verify same style object is shared
console.log(`\nSame style? ${characters[0].style === characters[1].style}`);

// Output:
// StyleFactory: Created new style 'Arial_12_black'
// Created 10010 characters
// Using only 1 style object(s)!
```

#### `Dart`

```dart
void main() {
  // Create 10,000 characters with shared styles
  final characters = <Character>[];
  final text = "Hello World! " * 770;

  for (var i = 0; i < text.length; i++) {
    // Factory returns cached style — same object for same parameters
    final style = StyleFactory.getStyle("Arial", 12, "black");
    characters.add(Character(text[i], style, i ~/ 80, i % 80));
  }

  print("\nCreated ${characters.length} characters");
  print("Using only ${StyleFactory.styleCount} style object(s)!");

  characters[0].render();  // 'H' at (0,0) [Arial, 12pt, black]
  characters[1].render();  // 'e' at (0,1) [Arial, 12pt, black]

  // Verify same style object is shared
  print("\nSame style? ${identical(characters[0].style, characters[1].style)}");

  // Output:
  // StyleFactory: Created new style 'Arial_12_black'
  // Created 10010 characters
  // Using only 1 style object(s)!
}
```

:::

## Summary

::: {.callout-tip appearance="simple" collapse="false"}
**Flyweight** shares common state among many objects by separating intrinsic (shared) state from extrinsic (unique) state, dramatically reducing memory usage.
:::

### Key Benefits

- **Memory Efficiency**: Thousands of objects can share a few flyweight instances
- **Scalability**: Memory usage grows with unique states, not object count
- **Performance**: Less memory allocation and garbage collection overhead
- **Immutability**: Flyweights are typically immutable, making them thread-safe

### When to Use

| ✅ Use When | ❌ Avoid When |
|------------|--------------|
| You need a huge number of similar objects | You have few objects or they're all unique |
| Objects contain significant duplicated state | Objects don't share significant state |
| Memory is a constraint | The complexity of separating state isn't worth it |
| Extrinsic state can be computed or passed in | Extrinsic state is expensive to compute each time |
